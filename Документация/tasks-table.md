#Документация проекта onlyReal

#Введение
В этом проекте перед командами стояла задача разработать грамматику языка и создать дял неё оптимизирующий компилятор.

Проект реализован на языке с#. Также были использованы генератор синтаксического анализатора Yacc и генератор лексического анализатора Lex.

#Структура проекта
<table>
    <thead>
    <tr>
        <th>Раздел</th>
        <th>Задача</th>
        <th>Название команды</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td>AST дерево</td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td></td>
        <td>Оптимизация операции умножения на единицу</td>
        <td>Roll</td>
    </tr>
    <tr>
        <td></td>
        <td>Оптимизация операции умножения на ноль</td>
        <td>Roslyn</td>
    </tr>
    <tr>
        <td></td>
        <td>Оптимизация перемножения констант</td>
        <td>komanda</td>
    </tr>
    <tr>
        <td></td>
        <td>Оптимизация суммирования с нулем</td>
        <td>SouthPark</td>
    </tr>
    <tr>
        <td></td>
        <td>Оптимизация вычитания собственного значения</td>
        <td>Nvidia</td>
    </tr>
    <tr>
        <td></td>
        <td>Оптимизация операции сравнения <</td>
        <td>GreatBean</td>
    </tr>
    <tr>
        <td></td>
        <td>Оптимизация операции сравнения ==</td>
        <td>Intel</td>
    </tr>
    <tr>
        <td></td>
        <td>Оптимизация операций сравнения с собой</td>
        <td>qwerty</td>
    </tr>
    <tr>
        <td></td>
        <td>Оптимизация операций >, !=</td>
        <td></td>
    </tr>
    <tr>
        <td></td>
        <td>Оптимизация присваивания собственного значения</td>
        <td>Nvidia, BOOM</td>
    </tr>
    <tr>
        <td></td>
        <td>Оптимизация if (true)</td>
        <td>Roslyn</td>
    </tr>
    <tr>
        <td></td>
        <td>Оптимизация if (false)</td>
        <td>GreatBean, komanda, Intel</td>
    </tr>
    <tr>
        <td></td>
        <td>Оптимизация if (ex) null else null</td>
        <td>qwerty</td>
    </tr>
    <tr>
        <td></td>
        <td>Оптимизация while (false)</td>
        <td>Roll</td>
    </tr>
    <tr>
        <td></td>
        <td>Удаление всех null</td>
        <td>BOOM</td>
    </tr>
    <tr>
        <td></td>
        <td>Оптимизация вложенных блоков</td>
        <td>SouthPark</td>
    </tr>
    <tr>
        <td>Трехадресный код</td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td></td>
        <td>Логические тождества < > and or true false</td>
        <td>GreatBean</td>
    </tr>
    <tr>
        <td></td>
        <td>Свертка const, алгебраические тождества (в т.ч. каскадные) + протяжка const</td>
        <td>Roslyn</td>
    </tr>
    <tr>
        <td></td>
        <td>Выделение ББл</td>
        <td>Nvidia</td>
    </tr>
    <tr>
        <td></td>
        <td>Живые и мёртвые переменные внутри ББл - анализ удаления мертвого кода (в т.ч. каскадное)</td>
        <td>Roll</td>
    </tr>
    <tr>
        <td></td>
        <td>Вычисление Def-Use: Удаление мертвого кода, протяжка const (каскадная)</td>
        <td>komanda</td>
    </tr>
    <tr>
        <td></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td></td>
        <td>Оптимизация общих подвыражений (простейшая) + протяжка копий</td>
        <td>qwerty</td>
    </tr>
    <tr>
        <td></td>
        <td>Очистка от пустых операторов устранение переходов через переходы</td>
        <td>SouthPark</td>
    </tr>
    <tr>
        <td></td>
        <td>Устранение недостижимого кода. Устранение переходов к переходам</td>
        <td>BOOM</td>
    </tr>
    <tr>
        <td></td>
        <td>Удаление мертвого кода, протяжка копий</td>
        <td>Intel</td>
    </tr>
    <tr>
        <td></td>
        <td>CFG</td>
        <td>Nvidia</td>
    </tr>
    <tr>
        <td></td>
        <td>Алгоритм LVN</td>
        <td>Roll</td>
    </tr>
    <tr>
        <td></td>
        <td>Устранение локальных общих подвыражений построением ациклического графа</td>
        <td>qwerty</td>
    </tr>
    <tr>
        <td></td>
        <td>Для достигающих определений вычислить genB, killB для любого B и разработать структуру для хранения передаточной функции.
            fB = fSn*fSn-1*...*fS1 - вычислить fSi для каждой инструкции ББл и потом найти композицию</td>
        <td>Roslyn</td>
    </tr>
    <tr>
        <td></td>
        <td>Хранение IN[B] и OUT[B] для ряда задач</td>
        <td>SouthPark</td>
    </tr>
    <tr>
        <td></td>
        <td>Для достигающих определений вычислить genB, killB для любого B и разработать структуру для хранения передаточной функции.
            Вычислить fB по яв. формулам fB(x)=genB U (x - killB) killB = kill1 U kill2 U ... U killn, gebB = ....</td>
        <td>Intel</td>
    </tr>
    <tr>
        <td></td>
        <td>Итерационный Алгоритм для достигающих определений</td>
        <td>Nvidia</td>
    </tr>
    <tr>
        <td></td>
        <td>Оптимизация на основе ИтА для активных переменных - удаление мертвого кода </td>
        <td>Roll</td>
    </tr>
    <tr>
        <td></td>
        <td>Оптимизация протяжка const на основе инф., полученной в результате применения ИтА для достиг. определений</td>
        <td>komanda</td>
    </tr>
    <tr>
        <td></td>
        <td>Вычисление множеств DEFb и USEb д/активных переменных</td>
        <td>qwerty</td>
    </tr>
    <tr>
        <td></td>
        <td>Итерационный алгоритм для активных переменных</td>
        <td>BOOM</td>
    </tr>
    <tr>
        <td></td>
        <td>Итерационный алгоритм для доступных выражений</td>
        <td>GreatBean</td>
    </tr>
    <tr>
        <td></td>
        <td>Класс передаточной функции (общий):
            - ф-ии формулой
            - ф-ии алгоритмом
            - суперпозиция ф-ий</td>
        <td>Roll</td>
    </tr>
    <tr>
        <td></td>
        <td>Доступные выражения-множества e_genB, e-KILLb. Передаточная функция ББл В.</td>
        <td>SouthPark</td>
    </tr>
    <tr>
        <td></td>
        <td>На основе анализа доступных выражений провести оптимизации</td>
        <td>BOOM</td>
    </tr>
    <tr>
        <td></td>
        <td>Генератор IL-кода</td>
        <td>Roslyn</td>
    </tr>
    <tr>
        <td></td>
        <td>Итерационный алгоритм в задаче растпространения констант</td>
        <td>Nvidia</td>
    </tr>
    <tr>
        <td></td>
        <td>Обобщенный итерационный алгоритм</td>
        <td>Roll</td>
    </tr>
    <tr>
        <td></td>
        <td>Оператор сбора и отображение m в задаче о распространении констант</td>
        <td>SouthPark</td>
    </tr>
    <tr>
        <td></td>
        <td>Поиск решения методом MOP</td>
        <td>Intel</td>
    </tr>
    <tr>
        <td></td>
        <td>Передаточная функция в задаче о распространении констант</td>
        <td>Roslyn</td>
    </tr>
    <tr>
        <td></td>
        <td>Вычисление доминаторов</td>
        <td>komanda</td>
    </tr>
    <tr>
        <td></td>
        <td>ControlFlowGraph перевести в Трехадресный код</td>
        <td>BOOM</td>
    </tr>
    <tr>
        <td></td>
        <td>Определение того, является ли ребро обратным и являеется ли CFG приводимым</td>
        <td>GreatBean</td>
    </tr>
    <tr>
        <td></td>
        <td>Определение глубины CFG</td>
        <td>Roll</td>
    </tr>
    <tr>
        <td></td>
        <td>Классификация ребер в глубинном остовном дереве </td>
        <td>qwerty</td>
    </tr>
    <tr>
        <td></td>
        <td>Построение глубинного остовного дерева с соответствующей нумерацией вершин</td>
        <td>SouthPark</td>
    </tr>
    <tr>
        <td></td>
        <td>Определение всех естественных циклов в CFG с информацией об их вложенности</td>
        <td>Intel</td>
    </tr>
    </tbody>
</table>